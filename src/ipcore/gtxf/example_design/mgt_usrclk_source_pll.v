///////////////////////////////////////////////////////////////////////////////
//   ____  ____
//  /   /\/   /
// /___/  \  /
// \   \   \/     Vendor : Xilinx
//  \   \         Version : 1.7
//  /   /         Application : GTX Transceiver Wizard
// /___/   /\     Filename : mgt_usrclk_source_pll.v
// \   \  /  \
//  \___\/\___\
//
//
// Module MGT_USRCLK_SOURCE (for use with GTX Transceivers)
// Generated by Xilinx GTX Transceiver Wizard
// 
// 
// (c) Copyright 2008 - 2009 Xilinx, Inc. All rights reserved.
// 
// This file contains confidential and proprietary information
// of Xilinx, Inc. and is protected under U.S. and
// international copyright and other intellectual property
// laws.
// 
// DISCLAIMER
// This disclaimer is not a license and does not grant any
// rights to the materials distributed herewith. Except as
// otherwise provided in a valid license issued to you by
// Xilinx, and to the maximum extent permitted by applicable
// law: (1) THESE MATERIALS ARE MADE AVAILABLE "AS IS" AND
// WITH ALL FAULTS, AND XILINX HEREBY DISCLAIMS ALL WARRANTIES
// AND CONDITIONS, EXPRESS, IMPLIED, OR STATUTORY, INCLUDING
// BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY, NON-
// INFRINGEMENT, OR FITNESS FOR ANY PARTICULAR PURPOSE; and
// (2) Xilinx shall not be liable (whether in contract or tort,
// including negligence, or under any other theory of
// liability) for any loss or damage of any kind or nature
// related to, arising under or in connection with these
// materials, including for any direct, or any indirect,
// special, incidental, or consequential loss or damage
// (including loss of data, profits, goodwill, or any type of
// loss or damage suffered as a result of any action brought
// by a third party) even if such damage or loss was
// reasonably foreseeable or Xilinx had been advised of the
// possibility of the same.
// 
// CRITICAL APPLICATIONS
// Xilinx products are not designed or intended to be fail-
// safe, or for use in any application requiring fail-safe
// performance, such as life-support or safety devices or
// systems, Class III medical devices, nuclear facilities,
// applications related to the deployment of airbags, or any
// other applications that could lead to death, personal
// injury, or severe property or environmental damage
// (individually and collectively, "Critical
// Applications"). Customer assumes the sole risk and
// liability of any use of Xilinx products in Critical
// Applications, subject only to applicable laws and
// regulations governing limitations on product liability.
// 
// THIS COPYRIGHT NOTICE AND DISCLAIMER MUST BE RETAINED AS
// PART OF THIS FILE AT ALL TIMES. 


`timescale 1ns / 1ps

//***********************************Entity Declaration*******************************
module MGT_USRCLK_SOURCE_PLL #
(
    parameter   MULT            =   2,
    parameter   DIVIDE          =   2,
    parameter   CLK_PERIOD      =   12.5,
    parameter   OUT0_DIVIDE     =   2,
    parameter   OUT1_DIVIDE     =   2,
    parameter   OUT2_DIVIDE     =   2,
    parameter   OUT3_DIVIDE     =   2, 
    parameter   SIMULATION_P    =   1, 
    parameter   LOCK_WAIT_COUNT =   16'b1000001000110101    
)
(
    CLK0_OUT,
    CLK1_OUT,
    CLK2_OUT,
    CLK3_OUT,
    CLK_IN,
    PLL_LOCKED_OUT,
    PLL_RESET_IN
);


`define DLY #1


//*********************************** Port Declaration *******************************

    output          CLK0_OUT;
    output          CLK1_OUT;
    output          CLK2_OUT;
    output          CLK3_OUT;
    input           CLK_IN;
    output          PLL_LOCKED_OUT;
    input           PLL_RESET_IN;

//*********************************Wire Declarations**********************************

    wire    [15:0]  tied_to_ground_vec_i;
    wire            tied_to_ground_i;
    wire            clkout0_i;
    wire            clkout1_i;
    wire            clkout2_i;
    wire            clkout3_i;
    wire            clkfbout_i;
    wire            pll_lk_out;

//*********************************Register Declarations**********************************  

    reg     [15:0]  lock_wait_counter; 
    reg             pll_locked_out_r;
    reg             time_elapsed;    

//*********************************** Beginning of Code *******************************

    //  Static signal Assigments    
    assign tied_to_ground_i             = 1'b0;
    assign tied_to_ground_vec_i         = 16'h0000;

    // Instantiate a DCM module to divide the reference clock. Uses internal feedback
    // for improved jitter performance, and to avoid consuming an additional BUFG
    PLL_ADV #
    (
         .CLKFBOUT_MULT     (MULT),
         .DIVCLK_DIVIDE     (DIVIDE),
         .CLKFBOUT_PHASE    (0),
         
         .CLKIN1_PERIOD     (CLK_PERIOD),
         .CLKIN2_PERIOD     (10),   //Not used
         
         .CLKOUT0_DIVIDE    (OUT0_DIVIDE),
         .CLKOUT0_PHASE     (0),
         
         .CLKOUT1_DIVIDE    (OUT1_DIVIDE),
         .CLKOUT1_PHASE     (0),

         .CLKOUT2_DIVIDE    (OUT2_DIVIDE),
         .CLKOUT2_PHASE     (0),
         
         .CLKOUT3_DIVIDE    (OUT3_DIVIDE),
         .CLKOUT3_PHASE     (0)        
    )
    pll_adv_i   
    (
         .CLKIN1            (CLK_IN),
         .CLKIN2            (1'b0),
         .CLKINSEL          (1'b1),
         .CLKFBIN           (clkfbout_i),
         .CLKOUT0           (clkout0_i),
         .CLKOUT1           (clkout1_i),
         .CLKOUT2           (clkout2_i),
         .CLKOUT3           (clkout3_i),
         .CLKOUT4           (),
         .CLKOUT5           (),
         .CLKFBOUT          (clkfbout_i),
         .CLKFBDCM          (),
         .CLKOUTDCM0        (),
         .CLKOUTDCM1        (),
         .CLKOUTDCM2        (),
         .CLKOUTDCM3        (),
         .CLKOUTDCM4        (),
         .CLKOUTDCM5        (),
         .DO                (),
         .DRDY              (),
         .DADDR             (5'd0),
         .DCLK              (1'b0),
         .DEN               (1'b0),
         .DI                (16'd0),
         .DWE               (1'b0),
         .REL               (1'b0),
         .LOCKED            (pll_lk_out),
         .RST               (PLL_RESET_IN)
    );
    
    BUFG clkout0_bufg_i  
    (
        .O              (CLK0_OUT), 
        .I              (clkout0_i)
    ); 


    BUFG clkout1_bufg_i
    (
        .O              (CLK1_OUT),
        .I              (clkout1_i)
    );


    BUFG clkout2_bufg_i 
    (
        .O              (CLK2_OUT),
        .I              (clkout2_i)
    );
    
    
    BUFG clkout3_bufg_i
    (
        .O              (CLK3_OUT),
        .I              (clkout3_i)
    );    

    generate
    if (SIMULATION_P == 1) 
    begin : lockwait_count
    
    // lock not valid until 100us after PLL is released from reset
    always@(posedge CLK_IN or posedge PLL_RESET_IN) 
    begin
        if (PLL_RESET_IN) begin
            lock_wait_counter <= 16'b0000000000000000; 
            pll_locked_out_r <= 1'b0;
            time_elapsed <= 1'b0;
        end
        else begin
            if (lock_wait_counter == LOCK_WAIT_COUNT | time_elapsed) begin
                pll_locked_out_r <= pll_lk_out; 
                time_elapsed <= 1'b1;
            end
            else 
                lock_wait_counter <= lock_wait_counter + 1; 
        end
    end
    
    assign PLL_LOCKED_OUT = pll_locked_out_r;
    
    end //  End SIMULATION_P=1 generate section
    else 
    begin: no_lockwait_count
    
    assign PLL_LOCKED_OUT = pll_lk_out;
    
    end
    endgenerate //  End generate for SIMULATION_P    

endmodule

